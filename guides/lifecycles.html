<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><title>Crank.js | Lifecycles</title><link rel="stylesheet" href="/index.css.css"></head><body><nav id="navbar" class="navbar"><div class="navbar-group"><div class="navbar-item"><a class href="/">Crank.js</a></div><div class="navbar-item"><a class="current" href="/guides/getting-started">Docs</a></div><div class="navbar-item"><a class href="/blog/">Blog</a></div></div><div class="navbar-group"><div class="navbar-item"><a href="https://github.com/bikeshaving/crank">GitHub</a></div><div class="navbar-item"><a href="http://npm.im/@bikeshaving/crank">NPM</a></div></div></nav><div id="sidebar" class="sidebar"><h3>Guides</h3><div class="sidebar-item"><a href="/guides/getting-started" class="">Getting Started</a></div><div class="sidebar-item"><a href="/guides/elements" class="">JSX, Elements and Renderers</a></div><div class="sidebar-item"><a href="/guides/components" class="">Components</a></div><div class="sidebar-item"><a href="/guides/async-components" class="">Async Components</a></div><div class="sidebar-item"><a href="/guides/special-tags-and-props" class="">Special Props and Tags</a></div><div class="sidebar-item"><a href="/guides/lifecycles" class="current">Lifecycles</a></div><div class="sidebar-item"><a href="/guides/working-with-typescript" class="">Working with TypeScript</a></div></div><div class="main"><div class="content"><h1>Lifecycles</h1><p>Crank uses the full power and expressiveness of generator functions to encapsulate the notion of lifecycles within the same scope. Internally, Crank achieves this by calling the calling the <code>next</code>, <code>return</code> and <code>throw</code> methods of the generator object as components are inserted, updated and removed from the element tree. As a developer, you can use the <code>yield</code>, <code>return</code>, <code>try</code>, <code>catch</code>, and <code>finally</code> keywords within your generator components to take full advantage of the generator’s natural lifecycle.</p>
<h2 id="returning-from-a-generator">Returning from a generator</h2>
<p>Usually, you’ll yield in generator components so that they can continue to respond to updates, but you may want to also <code>return</code> a final state. Unlike function components, which are called and returned once for each update, once a generator component returns, it will never update again.</p>
<pre><code class="language-jsx">function *Stuck({message}) {
  return &lt;div&gt;{message}&lt;/div&gt;;
}

renderer.render(&lt;Stuck message=&quot;Hello&quot; /&gt;, document.body);
console.log(document.body.innerHTML); // &quot;&lt;div&gt;Hello&lt;/div&gt;&quot;
renderer.render(&lt;Stuck message=&quot;Goodbye&quot; /&gt;, document.body);
console.log(document.body.innerHTML); // &quot;&lt;div&gt;Hello&lt;/div&gt;&quot;
renderer.render(&lt;Stuck message=&quot;Passing in new props is useless&quot; /&gt;, document.body);
console.log(document.body.innerHTML); // &quot;&lt;div&gt;Hello&lt;/div&gt;&quot;</code></pre>
<p>You should be careful when writing generator components to make sure that you always place your <code>yield</code> operators in a <code>for</code> or <code>while</code> loop. If you forget and implicitly return from the generator, it will stop updating, nothing will be rendered, and the only way to restart the component will be to remove it from the element tree and add it again.</p>
<pre><code class="language-jsx">function *Numbers() {
  yield 1;
  yield 2;
  yield 3;
}

renderer.render(&lt;Numbers /&gt;, document.body);
console.log(document.body.innerHTML); // &quot;1&quot;
renderer.render(&lt;Numbers /&gt;, document.body);
console.log(document.body.innerHTML); // &quot;2&quot;
renderer.render(&lt;Numbers /&gt;, document.body);
console.log(document.body.innerHTML); // &quot;3&quot;
renderer.render(&lt;Numbers /&gt;, document.body);
console.log(document.body.innerHTML); // &quot;&quot;
renderer.render(&lt;Numbers /&gt;, document.body);
console.log(document.body.innerHTML); // &quot;&quot;

renderer.render(null, document.body);
renderer.render(&lt;Numbers /&gt;, document.body);
console.log(document.body.innerHTML); // &quot;1&quot;</code></pre>
<h2 id="cleaning-up-after-your-components-are-removed">Cleaning up after your components are removed</h2>
<p>When a generator component is removed from the tree, Crank calls the <code>return</code> method on the generator object. You can think of it as whatever <code>yield</code> expression your component was suspended on being replaced by a <code>return</code> statement. This means that any loops that you were in when the generator was suspended is broken out of and no code after the . You can take advantage of this behavior by wrapping your <code>yield</code> loops in a <code>try</code>/<code>finally</code> to release any resources that your component may have used.</p>
<pre><code class="language-jsx">function *Cleanup() {
  try {
    while (true) {
      yield &quot;Hi&quot;;
    }
  } finally {
    console.log(&quot;finally block executed&quot;);
  }
}

renderer.render(&lt;Cleanup /&gt;, document.body);
console.log(document.body); // &quot;Hi&quot;
renderer.render(null, document.body);
// &quot;finally block executed&quot;
console.log(document.body); // &quot;&quot;</code></pre>
<p><a href="https://eslint.org/docs/rules/no-unsafe-finally">The same best practices</a> which apply to <code>try</code>/<code>finally</code> blocks with regular <code>return</code> statements apply to generators. In short, you should not yield or return anything in the <code>finally</code> block, Crank will not use these values and you might inadvertently swallow errors in your code or suspend your component in an unexpected location.</p>
<h2 id="catching-errors-thrown-by-children">Catching errors thrown by children</h2>
<p>We all make mistakes, and it can be useful to catch errors in our components so that we can show the user something or notify error-logging services. To facilitate this, Crank will catch errors thrown when rendering child elements and throw them back into parent generator components by calling the <code>throw</code> method on the generator object. You can imagine that the most recently suspended <code>yield</code> expression is replaced with a <code>throw</code> statement with the error set to whatever was thrown during rendering. You can take advantage of this behavior by wrapping your <code>yield</code> operations in a <code>try</code>/<code>catch</code> block to catch errors caused by children.</p>
<pre><code class="language-jsx">function Thrower() { 
  throw new Error(&quot;Hmmm&quot;);
}

function *Catcher() {
  try {
    yield &lt;Thrower /&gt;;
  } catch (err) {
    return &lt;div&gt;Error: {err.message}&lt;/div&gt;;
  }
}

renderer.render(&lt;Catcher /&gt;, document.body);
console.log(document.body.innerHTML); // &quot;&lt;div&gt;Error: Hmmm&lt;/div&gt;&quot;
renderer.render(&lt;Catcher /&gt;, document.body);
renderer.render(&lt;Catcher /&gt;, document.body);
renderer.render(&lt;Catcher /&gt;, document.body);
console.log(document.body.innerHTML); // &quot;&lt;div&gt;Error: Hmmm&lt;/div&gt;&quot;</code></pre>
<p>This component “sticks” at the return so that error message is shown until the component is unmounted. However, you may also want to recover from errors as well, and you can do this by ignoring or handling the error.</p>
<pre><code class="language-jsx">function T1000() { 
  throw new Error(&quot;Die!!!&quot;);
}

function *Terminator() {
  while (true) {
    yield &lt;div&gt;Come with me if you want to live&lt;/div&gt;;
    try {
      yield &lt;T1000 /&gt;;
    } catch (err) {
      yield &lt;div&gt;I’ll be back&lt;/div&gt;;
    }
  }
}

renderer.render(&lt;Terminator /&gt;, document.body);
console.log(document.body.innerHTML); // &quot;&lt;div&gt;Come with me if you want to live&lt;/div&gt;&quot;
renderer.render(&lt;Terminator /&gt;, document.body);
console.log(document.body.innerHTML); // &quot;&lt;div&gt;I’ll be back&lt;/div&gt;&quot;
renderer.render(&lt;Terminator /&gt;, document.body);
console.log(document.body.innerHTML); // &quot;&lt;div&gt;Come with me if you want to live&lt;/div&gt;&quot;
renderer.render(&lt;Terminator /&gt;, document.body);
console.log(document.body.innerHTML); // &quot;&lt;div&gt;I’ll be back&lt;/div&gt;&quot;</code></pre>
<p>Note that you can’t catch or recover from errors thrown from within the generator themselves, the yield operator only throws errors which were thrown in the course of rendering child elements.</p>
<h2 id="accessing-rendered-values">Accessing rendered values</h2>
<p>Sometimes, the declarative rendering of DOM nodes is not enough, and you’ll want to access the actual DOM nodes you’ve rendered, to make measurements or call imperative methods like <code>el.focus()</code>, for instance. To facilitate this, Crank will pass rendered DOM nodes back into the generator using the <code>next</code> method, so <code>yield</code> expressions can be read and assigned to access the actual rendered DOM nodes.</p>
<pre><code class="language-jsx">async function *MyInput(props) {
  let input; 
  for await (props of this) {
    input = yield &lt;input {...props}/&gt;;
    input.focus();
  }
}</code></pre>
<p>The above component focuses every time it is rerendered. You might notice that we use an async generator component here. That’s because async generators continuously resume, and rely on the <code>for await</code> loop to await new updates.</p>
<p><strong>TODO: Design APIs/Document them for working with yield expressions in sync generators.</strong></p>
</div></div><script src="/index.tsx.js"></script></body></html>